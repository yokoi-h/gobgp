// Code generated by protoc-gen-go.
// source: neighbor_service.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	neighbor_service.proto

It has these top-level messages:
	ResponseType
	RequestType
	Neighbor
*/
package proto

import proto1 "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal

type ResponseType struct {
}

func (m *ResponseType) Reset()         { *m = ResponseType{} }
func (m *ResponseType) String() string { return proto1.CompactTextString(m) }
func (*ResponseType) ProtoMessage()    {}

type RequestType struct {
}

func (m *RequestType) Reset()         { *m = RequestType{} }
func (m *RequestType) String() string { return proto1.CompactTextString(m) }
func (*RequestType) ProtoMessage()    {}

type Neighbor struct {
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	State   string `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *Neighbor) Reset()         { *m = Neighbor{} }
func (m *Neighbor) String() string { return proto1.CompactTextString(m) }
func (*Neighbor) ProtoMessage()    {}

func init() {
}

// Client API for NeighborService service

type NeighborServiceClient interface {
	ListNeighbor(ctx context.Context, in *RequestType, opts ...grpc.CallOption) (NeighborService_ListNeighborClient, error)
}

type neighborServiceClient struct {
	cc *grpc.ClientConn
}

func NewNeighborServiceClient(cc *grpc.ClientConn) NeighborServiceClient {
	return &neighborServiceClient{cc}
}

func (c *neighborServiceClient) ListNeighbor(ctx context.Context, in *RequestType, opts ...grpc.CallOption) (NeighborService_ListNeighborClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NeighborService_serviceDesc.Streams[0], c.cc, "/proto.NeighborService/ListNeighbor", opts...)
	if err != nil {
		return nil, err
	}
	x := &neighborServiceListNeighborClient{stream}
	if err := x.ClientStream.SendProto(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NeighborService_ListNeighborClient interface {
	Recv() (*Neighbor, error)
	grpc.ClientStream
}

type neighborServiceListNeighborClient struct {
	grpc.ClientStream
}

func (x *neighborServiceListNeighborClient) Recv() (*Neighbor, error) {
	m := new(Neighbor)
	if err := x.ClientStream.RecvProto(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NeighborService service

type NeighborServiceServer interface {
	ListNeighbor(*RequestType, NeighborService_ListNeighborServer) error
}

func RegisterNeighborServiceServer(s *grpc.Server, srv NeighborServiceServer) {
	s.RegisterService(&_NeighborService_serviceDesc, srv)
}

func _NeighborService_ListNeighbor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RequestType)
	if err := stream.RecvProto(m); err != nil {
		return err
	}
	return srv.(NeighborServiceServer).ListNeighbor(m, &neighborServiceListNeighborServer{stream})
}

type NeighborService_ListNeighborServer interface {
	Send(*Neighbor) error
	grpc.ServerStream
}

type neighborServiceListNeighborServer struct {
	grpc.ServerStream
}

func (x *neighborServiceListNeighborServer) Send(m *Neighbor) error {
	return x.ServerStream.SendProto(m)
}

var _NeighborService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.NeighborService",
	HandlerType: (*NeighborServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListNeighbor",
			Handler:       _NeighborService_ListNeighbor_Handler,
			ServerStreams: true,
		},
	},
}
